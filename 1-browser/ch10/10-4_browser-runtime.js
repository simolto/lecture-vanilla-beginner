// 10-4. 이벤트 루프 - 브라우저 런타임 환경

// 설명: 브라우저에서 제공하는 Web APIs를 활용하면 멀티 쓰레딩이 가능합니다.
//  웹 APIs와 자바스크립트 엔진은 서로 협력하며 일을 수행합니다.
//  setTimeout을 예로들면 해당 함수의 콜백 함수로 실행되는 무언가가 있다면 콜백 자체를 task queue에 집어넣습니다.
//  task queue는 자료 구조로서 FIFO(first in first out)라고 불립니다.
//  queue의 대표적인 API는 add 또는 remove가 있는데 큐는 해당 API를 통해 가장 처음에 들어왔던 자료가 가장 먼저 나갈 수 있도록 만들어졌습니다.
//  task queue에 있는 콜백은 이벤트 루프를 통해 콜 스택과 태스크를 관찰합니다.
//  이벤트 루프는 콜 스택에 무언가 있으면 콜 스택이 비워질 때까지 기다립니다.
//  만약 함수 실행이 모두 끝나고 자바스크립트가 실행되지 않을 때 이벤트 루프는 태스크 큐에 있는 콜백을 콜 스택으로 가져옵니다.
//  가져온 콜백은 자바스크립트 엔진이 실행합니다.
//  이벤트 루프는 1ms 만큼 빠르게 도는데 사용자가 경험하기에 가장 좋은 프레임은 60fps 이기 때문에 render tree를 바로 업데이트 하는 것이 아니라
//  조금 기다렸다가 업데이트 합니다.(브라우저 마다 약간 다르지만 60fps에 거의 맞게 활용된다고 함)
//  이벤트 루프가 기다릴 때는 마냥 기다리지 않고 microtask queue로 넘어가서 텅텅 빌때까지 하나씩 가져오는 역할을 합니다. 그 다음 task queue로 가서 가져옵니다.
//  그래서 콜백 내부에 작성된 코스는 순서와 상관이 없습니다. 전체적으로 결정된 것들이 layout과 paint에 걸쳐서 브라우저에 표기되기 때문입니다.

/**
 * 브라우저 Web APIs 예시
 *  - DOM API
 *  - setTimeout()
 *  - setInterval()
 *  - fetch()
 *  - event listener
 */

// 참고: 리액트에서 컴포넌트 안에서 발생하는 이벤트를 처리 해야 하는 경우라면 꼭 리액트의 synthetic events를 사용합니다.
//  addEventListener를 따로 등록하지 않고 onClick에 함수를 할당해서 진행하는데
//  만약 addEventListener를 등록하려고 하면 ComponentDidMount에서 addEventListener를 해주고, ComponentWillUnmount에서 removeEventListener를 해야 합니다.
//  이것은 useEffect를 사용할 때도 마찬가지입니다. 등록, 삭제 코드를 작성해야 하는데요,
//  리액트 라이프 사이클에서 왜 이벤트리스너를 등록, 삭제를 해주어야 하는지 모호할 수 있습니다.

//  리액트에서 제공하는 onClick 이벤트를 활용하는데요.
//  그러나 컴포넌트와 연관 없는 이벤트를 처리 해야 할때, 예를 들면 컴포넌트 안에서 윈도우 스크롤링 이벤트를 듣고 그것을 처리하고 싶다면
//  그때는 일반 자바스크립트에서(처럼) addEventListener를 사용해야 합니다.
//  그러나 그 때는 ComponentDidMount에서 등록하고 ComponentWillUnmount에서 삭제를 해야 합니다.
//  삭제해 주지 않으면 콜 스택에 계속 쌓여서 덮어지게 되어 콜 스택을 낭비하게 됩니다. 한번 불려온다고 해당 이벤트 리스너가 삭제되는 것은 아니니 해당 유의사항을 유념하는 것이 좋습니다.

//  따라서 removeEventListener는 이벤트 리스너가 더 이상 필요하지 않을 때 사용되며,
//  이러한 관행은 코드의 가독성, 메모리 누수 방지, 유지보수성, 성능, 안정성 등을 향상시키는데 도움이 되는 것이 보편적인 의견입니다.
//  그러나 모든 개발자가 엄격하게 이를 준수하지 않을 수 있습니다.
//  이러한 차이점은 각 개발자나 팀의 선택 및 프로젝트의 요구사항에 따라 달라질 수 있습니다.
//  정확히 말하자면 removeEventListener는 이벤트 리스너가 더 이상 필요하지 않을 때 사용하고
//  필요한 이벤트 리스너를 등록한 후 그것을 계속 유지해야 할 경우에는 사용할 필요가 없겠습니다.
